<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * REST API Documentation
 *
 * Can not resolve Intro.md
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.18
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation dELETEAgentsId
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dELETEAgentsId($id, $authorization = null)
    {
        $this->dELETEAgentsIdWithHttpInfo($id, $authorization);
    }

    /**
     * Operation dELETEAgentsIdWithHttpInfo
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dELETEAgentsIdWithHttpInfo($id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEAgentsIdRequest($id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dELETEAgentsIdAsync
     *
     * 
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEAgentsIdAsync($id, $authorization = null)
    {
        return $this->dELETEAgentsIdAsyncWithHttpInfo($id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dELETEAgentsIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEAgentsIdAsyncWithHttpInfo($id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEAgentsIdRequest($id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dELETEAgentsId'
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dELETEAgentsIdRequest($id, $authorization = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling dELETEAgentsId'
            );
        }

        $resourcePath = '/agents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedId
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dELETEConsolidatedShipmentsConsolidatedId($consolidated_id, $authorization = null)
    {
        $this->dELETEConsolidatedShipmentsConsolidatedIdWithHttpInfo($consolidated_id, $authorization);
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdWithHttpInfo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdWithHttpInfo($consolidated_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEConsolidatedShipmentsConsolidatedIdRequest($consolidated_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdAsync
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdAsync($consolidated_id, $authorization = null)
    {
        return $this->dELETEConsolidatedShipmentsConsolidatedIdAsyncWithHttpInfo($consolidated_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdAsyncWithHttpInfo($consolidated_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEConsolidatedShipmentsConsolidatedIdRequest($consolidated_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dELETEConsolidatedShipmentsConsolidatedId'
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dELETEConsolidatedShipmentsConsolidatedIdRequest($consolidated_id, $authorization = null)
    {
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling dELETEConsolidatedShipmentsConsolidatedId'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $part_order_no The order no of a parcel group. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNo($consolidated_id, $part_order_no, $authorization = null)
    {
        $this->dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoWithHttpInfo($consolidated_id, $part_order_no, $authorization);
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoWithHttpInfo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $part_order_no The order no of a parcel group. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoWithHttpInfo($consolidated_id, $part_order_no, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoRequest($consolidated_id, $part_order_no, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoAsync
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $part_order_no The order no of a parcel group. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoAsync($consolidated_id, $part_order_no, $authorization = null)
    {
        return $this->dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoAsyncWithHttpInfo($consolidated_id, $part_order_no, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $part_order_no The order no of a parcel group. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoAsyncWithHttpInfo($consolidated_id, $part_order_no, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoRequest($consolidated_id, $part_order_no, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNo'
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $part_order_no The order no of a parcel group. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNoRequest($consolidated_id, $part_order_no, $authorization = null)
    {
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNo'
            );
        }
        // verify the required parameter 'part_order_no' is set
        if ($part_order_no === null || (is_array($part_order_no) && count($part_order_no) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $part_order_no when calling dELETEConsolidatedShipmentsConsolidatedIdParcelPartOrderNo'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/parcel/{partOrderNo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }
        // path params
        if ($part_order_no !== null) {
            $resourcePath = str_replace(
                '{' . 'partOrderNo' . '}',
                ObjectSerializer::toPathValue($part_order_no),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dELETEPreparedShipmentsPrepareId
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dELETEPreparedShipmentsPrepareId($prepare_id, $authorization = null)
    {
        $this->dELETEPreparedShipmentsPrepareIdWithHttpInfo($prepare_id, $authorization);
    }

    /**
     * Operation dELETEPreparedShipmentsPrepareIdWithHttpInfo
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dELETEPreparedShipmentsPrepareIdWithHttpInfo($prepare_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEPreparedShipmentsPrepareIdRequest($prepare_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dELETEPreparedShipmentsPrepareIdAsync
     *
     * 
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEPreparedShipmentsPrepareIdAsync($prepare_id, $authorization = null)
    {
        return $this->dELETEPreparedShipmentsPrepareIdAsyncWithHttpInfo($prepare_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dELETEPreparedShipmentsPrepareIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEPreparedShipmentsPrepareIdAsyncWithHttpInfo($prepare_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEPreparedShipmentsPrepareIdRequest($prepare_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dELETEPreparedShipmentsPrepareId'
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dELETEPreparedShipmentsPrepareIdRequest($prepare_id, $authorization = null)
    {
        // verify the required parameter 'prepare_id' is set
        if ($prepare_id === null || (is_array($prepare_id) && count($prepare_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepare_id when calling dELETEPreparedShipmentsPrepareId'
            );
        }

        $resourcePath = '/prepared-shipments/{prepareId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($prepare_id !== null) {
            $resourcePath = str_replace(
                '{' . 'prepareId' . '}',
                ObjectSerializer::toPathValue($prepare_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dELETEShipmentsShipmentId
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dELETEShipmentsShipmentId($shipment_id, $authorization = null)
    {
        $this->dELETEShipmentsShipmentIdWithHttpInfo($shipment_id, $authorization);
    }

    /**
     * Operation dELETEShipmentsShipmentIdWithHttpInfo
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dELETEShipmentsShipmentIdWithHttpInfo($shipment_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEShipmentsShipmentIdRequest($shipment_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dELETEShipmentsShipmentIdAsync
     *
     * 
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEShipmentsShipmentIdAsync($shipment_id, $authorization = null)
    {
        return $this->dELETEShipmentsShipmentIdAsyncWithHttpInfo($shipment_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dELETEShipmentsShipmentIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEShipmentsShipmentIdAsyncWithHttpInfo($shipment_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEShipmentsShipmentIdRequest($shipment_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dELETEShipmentsShipmentId'
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dELETEShipmentsShipmentIdRequest($shipment_id, $authorization = null)
    {
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling dELETEShipmentsShipmentId'
            );
        }

        $resourcePath = '/shipments/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dELETEStoredShipmentsStoredId
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dELETEStoredShipmentsStoredId($stored_id, $authorization = null)
    {
        $this->dELETEStoredShipmentsStoredIdWithHttpInfo($stored_id, $authorization);
    }

    /**
     * Operation dELETEStoredShipmentsStoredIdWithHttpInfo
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dELETEStoredShipmentsStoredIdWithHttpInfo($stored_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEStoredShipmentsStoredIdRequest($stored_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation dELETEStoredShipmentsStoredIdAsync
     *
     * 
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEStoredShipmentsStoredIdAsync($stored_id, $authorization = null)
    {
        return $this->dELETEStoredShipmentsStoredIdAsyncWithHttpInfo($stored_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dELETEStoredShipmentsStoredIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dELETEStoredShipmentsStoredIdAsyncWithHttpInfo($stored_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->dELETEStoredShipmentsStoredIdRequest($stored_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dELETEStoredShipmentsStoredId'
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dELETEStoredShipmentsStoredIdRequest($stored_id, $authorization = null)
    {
        // verify the required parameter 'stored_id' is set
        if ($stored_id === null || (is_array($stored_id) && count($stored_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stored_id when calling dELETEStoredShipmentsStoredId'
            );
        }

        $resourcePath = '/stored-shipments/{storedId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($stored_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storedId' . '}',
                ObjectSerializer::toPathValue($stored_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETAddressesAgents
     *
     * @param  string $type Type of agents to find. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $id The ID of the agent used by the carrier. NOTE: Can&#x27;t be used with zip or street parameters. (optional)
     * @param  string $zip The zip code of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     * @param  string $street The street name and number of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse200[]
     */
    public function gETAddressesAgents($type, $country_code, $authorization = null, $id = null, $zip = null, $street = null)
    {
        list($response) = $this->gETAddressesAgentsWithHttpInfo($type, $country_code, $authorization, $id, $zip, $street);
        return $response;
    }

    /**
     * Operation gETAddressesAgentsWithHttpInfo
     *
     * @param  string $type Type of agents to find. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $id The ID of the agent used by the carrier. NOTE: Can&#x27;t be used with zip or street parameters. (optional)
     * @param  string $zip The zip code of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     * @param  string $street The street name and number of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse200[], HTTP status code, HTTP response headers (array of strings)
     */
    public function gETAddressesAgentsWithHttpInfo($type, $country_code, $authorization = null, $id = null, $zip = null, $street = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200[]';
        $request = $this->gETAddressesAgentsRequest($type, $country_code, $authorization, $id, $zip, $street);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse200[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETAddressesAgentsAsync
     *
     * 
     *
     * @param  string $type Type of agents to find. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $id The ID of the agent used by the carrier. NOTE: Can&#x27;t be used with zip or street parameters. (optional)
     * @param  string $zip The zip code of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     * @param  string $street The street name and number of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETAddressesAgentsAsync($type, $country_code, $authorization = null, $id = null, $zip = null, $street = null)
    {
        return $this->gETAddressesAgentsAsyncWithHttpInfo($type, $country_code, $authorization, $id, $zip, $street)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETAddressesAgentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $type Type of agents to find. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $id The ID of the agent used by the carrier. NOTE: Can&#x27;t be used with zip or street parameters. (optional)
     * @param  string $zip The zip code of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     * @param  string $street The street name and number of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETAddressesAgentsAsyncWithHttpInfo($type, $country_code, $authorization = null, $id = null, $zip = null, $street = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200[]';
        $request = $this->gETAddressesAgentsRequest($type, $country_code, $authorization, $id, $zip, $street);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETAddressesAgents'
     *
     * @param  string $type Type of agents to find. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $id The ID of the agent used by the carrier. NOTE: Can&#x27;t be used with zip or street parameters. (optional)
     * @param  string $zip The zip code of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     * @param  string $street The street name and number of the receiver&#x27;s address. NOTE: Can&#x27;t be used with the id parameter. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETAddressesAgentsRequest($type, $country_code, $authorization = null, $id = null, $zip = null, $street = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling gETAddressesAgents'
            );
        }
        // verify the required parameter 'country_code' is set
        if ($country_code === null || (is_array($country_code) && count($country_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_code when calling gETAddressesAgents'
            );
        }

        $resourcePath = '/addresses/agents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($zip !== null) {
            $queryParams['zip'] = ObjectSerializer::toQueryValue($zip);
        }
        // query params
        if ($street !== null) {
            $queryParams['street'] = ObjectSerializer::toQueryValue($street);
        }
        // query params
        if ($country_code !== null) {
            $queryParams['countryCode'] = ObjectSerializer::toQueryValue($country_code);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETAddressesZipcodes
     *
     * @param  string $zip The zip code to get information about. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function gETAddressesZipcodes($zip, $country_code, $authorization = null)
    {
        list($response) = $this->gETAddressesZipcodesWithHttpInfo($zip, $country_code, $authorization);
        return $response;
    }

    /**
     * Operation gETAddressesZipcodesWithHttpInfo
     *
     * @param  string $zip The zip code to get information about. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETAddressesZipcodesWithHttpInfo($zip, $country_code, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->gETAddressesZipcodesRequest($zip, $country_code, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETAddressesZipcodesAsync
     *
     * 
     *
     * @param  string $zip The zip code to get information about. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETAddressesZipcodesAsync($zip, $country_code, $authorization = null)
    {
        return $this->gETAddressesZipcodesAsyncWithHttpInfo($zip, $country_code, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETAddressesZipcodesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $zip The zip code to get information about. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETAddressesZipcodesAsyncWithHttpInfo($zip, $country_code, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->gETAddressesZipcodesRequest($zip, $country_code, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETAddressesZipcodes'
     *
     * @param  string $zip The zip code to get information about. (required)
     * @param  string $country_code Two letter country code (from ISO-3166-1 alpha-2). (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETAddressesZipcodesRequest($zip, $country_code, $authorization = null)
    {
        // verify the required parameter 'zip' is set
        if ($zip === null || (is_array($zip) && count($zip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zip when calling gETAddressesZipcodes'
            );
        }
        // verify the required parameter 'country_code' is set
        if ($country_code === null || (is_array($country_code) && count($country_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_code when calling gETAddressesZipcodes'
            );
        }

        $resourcePath = '/addresses/zipcodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($zip !== null) {
            $queryParams['zip'] = ObjectSerializer::toQueryValue($zip);
        }
        // query params
        if ($country_code !== null) {
            $queryParams['countryCode'] = ObjectSerializer::toQueryValue($country_code);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETAlerts
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AlertInfoList
     */
    public function gETAlerts($authorization = null, $fetch_id = null)
    {
        list($response) = $this->gETAlertsWithHttpInfo($authorization, $fetch_id);
        return $response;
    }

    /**
     * Operation gETAlertsWithHttpInfo
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AlertInfoList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETAlertsWithHttpInfo($authorization = null, $fetch_id = null)
    {
        $returnType = '\Swagger\Client\Model\AlertInfoList';
        $request = $this->gETAlertsRequest($authorization, $fetch_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AlertInfoList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETAlertsAsync
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETAlertsAsync($authorization = null, $fetch_id = null)
    {
        return $this->gETAlertsAsyncWithHttpInfo($authorization, $fetch_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETAlertsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETAlertsAsyncWithHttpInfo($authorization = null, $fetch_id = null)
    {
        $returnType = '\Swagger\Client\Model\AlertInfoList';
        $request = $this->gETAlertsRequest($authorization, $fetch_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETAlerts'
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETAlertsRequest($authorization = null, $fetch_id = null)
    {

        $resourcePath = '/alerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fetch_id !== null) {
            $queryParams['fetchId'] = ObjectSerializer::toQueryValue($fetch_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETConsolidatedShipments
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfoList
     */
    public function gETConsolidatedShipments($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        list($response) = $this->gETConsolidatedShipmentsWithHttpInfo($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status);
        return $response;
    }

    /**
     * Operation gETConsolidatedShipmentsWithHttpInfo
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfoList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETConsolidatedShipmentsWithHttpInfo($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfoList';
        $request = $this->gETConsolidatedShipmentsRequest($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfoList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETConsolidatedShipmentsAsync
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsAsync($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        return $this->gETConsolidatedShipmentsAsyncWithHttpInfo($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETConsolidatedShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsAsyncWithHttpInfo($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfoList';
        $request = $this->gETConsolidatedShipmentsRequest($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETConsolidatedShipments'
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETConsolidatedShipmentsRequest($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {

        $resourcePath = '/consolidated-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_field !== null) {
            $queryParams['searchField'] = ObjectSerializer::toQueryValue($search_field);
        }
        // query params
        if ($search_op !== null) {
            $queryParams['searchOp'] = ObjectSerializer::toQueryValue($search_op);
        }
        // query params
        if ($search_value !== null) {
            $queryParams['searchValue'] = ObjectSerializer::toQueryValue($search_value);
        }
        // query params
        if ($date_type !== null) {
            $queryParams['dateType'] = ObjectSerializer::toQueryValue($date_type);
        }
        // query params
        if ($date_from !== null) {
            $queryParams['dateFrom'] = ObjectSerializer::toQueryValue($date_from);
        }
        // query params
        if ($date_to !== null) {
            $queryParams['dateTo'] = ObjectSerializer::toQueryValue($date_to);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfs
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PdfList
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfs($consolidated_id, $authorization = null, $inline_pdf = null)
    {
        list($response) = $this->gETConsolidatedShipmentsConsolidatedIdPdfsWithHttpInfo($consolidated_id, $authorization, $inline_pdf);
        return $response;
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsWithHttpInfo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PdfList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsWithHttpInfo($consolidated_id, $authorization = null, $inline_pdf = null)
    {
        $returnType = '\Swagger\Client\Model\PdfList';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPdfsRequest($consolidated_id, $authorization, $inline_pdf);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PdfList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsAsync
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsAsync($consolidated_id, $authorization = null, $inline_pdf = null)
    {
        return $this->gETConsolidatedShipmentsConsolidatedIdPdfsAsyncWithHttpInfo($consolidated_id, $authorization, $inline_pdf)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsAsyncWithHttpInfo($consolidated_id, $authorization = null, $inline_pdf = null)
    {
        $returnType = '\Swagger\Client\Model\PdfList';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPdfsRequest($consolidated_id, $authorization, $inline_pdf);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETConsolidatedShipmentsConsolidatedIdPdfs'
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETConsolidatedShipmentsConsolidatedIdPdfsRequest($consolidated_id, $authorization = null, $inline_pdf = null)
    {
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling gETConsolidatedShipmentsConsolidatedIdPdfs'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/pdfs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_pdf !== null) {
            $queryParams['inlinePdf'] = ObjectSerializer::toQueryValue($inline_pdf);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsPdfId
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsPdfId($pdf_id, $consolidated_id, $authorization = null)
    {
        $this->gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdWithHttpInfo($pdf_id, $consolidated_id, $authorization);
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdWithHttpInfo
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdWithHttpInfo($pdf_id, $consolidated_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdRequest($pdf_id, $consolidated_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdAsync
     *
     * 
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdAsync($pdf_id, $consolidated_id, $authorization = null)
    {
        return $this->gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdAsyncWithHttpInfo($pdf_id, $consolidated_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdAsyncWithHttpInfo($pdf_id, $consolidated_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdRequest($pdf_id, $consolidated_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETConsolidatedShipmentsConsolidatedIdPdfsPdfId'
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETConsolidatedShipmentsConsolidatedIdPdfsPdfIdRequest($pdf_id, $consolidated_id, $authorization = null)
    {
        // verify the required parameter 'pdf_id' is set
        if ($pdf_id === null || (is_array($pdf_id) && count($pdf_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_id when calling gETConsolidatedShipmentsConsolidatedIdPdfsPdfId'
            );
        }
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling gETConsolidatedShipmentsConsolidatedIdPdfsPdfId'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/pdfs/{pdfId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($pdf_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pdfId' . '}',
                ObjectSerializer::toPathValue($pdf_id),
                $resourcePath
            );
        }
        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrints
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PrintList
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrints($consolidated_id, $authorization = null, $return_file = null)
    {
        list($response) = $this->gETConsolidatedShipmentsConsolidatedIdPrintsWithHttpInfo($consolidated_id, $authorization, $return_file);
        return $response;
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsWithHttpInfo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PrintList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsWithHttpInfo($consolidated_id, $authorization = null, $return_file = null)
    {
        $returnType = '\Swagger\Client\Model\PrintList';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPrintsRequest($consolidated_id, $authorization, $return_file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PrintList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsAsync
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsAsync($consolidated_id, $authorization = null, $return_file = null)
    {
        return $this->gETConsolidatedShipmentsConsolidatedIdPrintsAsyncWithHttpInfo($consolidated_id, $authorization, $return_file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsAsyncWithHttpInfo($consolidated_id, $authorization = null, $return_file = null)
    {
        $returnType = '\Swagger\Client\Model\PrintList';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPrintsRequest($consolidated_id, $authorization, $return_file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETConsolidatedShipmentsConsolidatedIdPrints'
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETConsolidatedShipmentsConsolidatedIdPrintsRequest($consolidated_id, $authorization = null, $return_file = null)
    {
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling gETConsolidatedShipmentsConsolidatedIdPrints'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/prints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($return_file !== null) {
            $queryParams['returnFile'] = ObjectSerializer::toQueryValue($return_file);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsPrintId
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsPrintId($print_id, $consolidated_id, $authorization = null)
    {
        $this->gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdWithHttpInfo($print_id, $consolidated_id, $authorization);
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdWithHttpInfo
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdWithHttpInfo($print_id, $consolidated_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdRequest($print_id, $consolidated_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdAsync
     *
     * 
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdAsync($print_id, $consolidated_id, $authorization = null)
    {
        return $this->gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdAsyncWithHttpInfo($print_id, $consolidated_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdAsyncWithHttpInfo($print_id, $consolidated_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdRequest($print_id, $consolidated_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETConsolidatedShipmentsConsolidatedIdPrintsPrintId'
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETConsolidatedShipmentsConsolidatedIdPrintsPrintIdRequest($print_id, $consolidated_id, $authorization = null)
    {
        // verify the required parameter 'print_id' is set
        if ($print_id === null || (is_array($print_id) && count($print_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $print_id when calling gETConsolidatedShipmentsConsolidatedIdPrintsPrintId'
            );
        }
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling gETConsolidatedShipmentsConsolidatedIdPrintsPrintId'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/prints/{printId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($print_id !== null) {
            $resourcePath = str_replace(
                '{' . 'printId' . '}',
                ObjectSerializer::toPathValue($print_id),
                $resourcePath
            );
        }
        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETDeliveryCheckoutsDeliveryCheckoutId
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $language The language to be used for delivery checkout. (required)
     * @param  string $currency The currency to be used for the delivery checkout. (required)
     * @param  string $tocountry ISO code for receiving country according to Country information in Unifaun Code Lists. (required)
     * @param  string $tozipcode Zip code for the receiving address. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FreightCheckout
     */
    public function gETDeliveryCheckoutsDeliveryCheckoutId($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization = null)
    {
        list($response) = $this->gETDeliveryCheckoutsDeliveryCheckoutIdWithHttpInfo($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization);
        return $response;
    }

    /**
     * Operation gETDeliveryCheckoutsDeliveryCheckoutIdWithHttpInfo
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $language The language to be used for delivery checkout. (required)
     * @param  string $currency The currency to be used for the delivery checkout. (required)
     * @param  string $tocountry ISO code for receiving country according to Country information in Unifaun Code Lists. (required)
     * @param  string $tozipcode Zip code for the receiving address. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FreightCheckout, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETDeliveryCheckoutsDeliveryCheckoutIdWithHttpInfo($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\FreightCheckout';
        $request = $this->gETDeliveryCheckoutsDeliveryCheckoutIdRequest($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FreightCheckout',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETDeliveryCheckoutsDeliveryCheckoutIdAsync
     *
     * 
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $language The language to be used for delivery checkout. (required)
     * @param  string $currency The currency to be used for the delivery checkout. (required)
     * @param  string $tocountry ISO code for receiving country according to Country information in Unifaun Code Lists. (required)
     * @param  string $tozipcode Zip code for the receiving address. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETDeliveryCheckoutsDeliveryCheckoutIdAsync($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization = null)
    {
        return $this->gETDeliveryCheckoutsDeliveryCheckoutIdAsyncWithHttpInfo($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETDeliveryCheckoutsDeliveryCheckoutIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $language The language to be used for delivery checkout. (required)
     * @param  string $currency The currency to be used for the delivery checkout. (required)
     * @param  string $tocountry ISO code for receiving country according to Country information in Unifaun Code Lists. (required)
     * @param  string $tozipcode Zip code for the receiving address. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETDeliveryCheckoutsDeliveryCheckoutIdAsyncWithHttpInfo($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\FreightCheckout';
        $request = $this->gETDeliveryCheckoutsDeliveryCheckoutIdRequest($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETDeliveryCheckoutsDeliveryCheckoutId'
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $language The language to be used for delivery checkout. (required)
     * @param  string $currency The currency to be used for the delivery checkout. (required)
     * @param  string $tocountry ISO code for receiving country according to Country information in Unifaun Code Lists. (required)
     * @param  string $tozipcode Zip code for the receiving address. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETDeliveryCheckoutsDeliveryCheckoutIdRequest($delivery_checkout_id, $language, $currency, $tocountry, $tozipcode, $authorization = null)
    {
        // verify the required parameter 'delivery_checkout_id' is set
        if ($delivery_checkout_id === null || (is_array($delivery_checkout_id) && count($delivery_checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delivery_checkout_id when calling gETDeliveryCheckoutsDeliveryCheckoutId'
            );
        }
        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling gETDeliveryCheckoutsDeliveryCheckoutId'
            );
        }
        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling gETDeliveryCheckoutsDeliveryCheckoutId'
            );
        }
        // verify the required parameter 'tocountry' is set
        if ($tocountry === null || (is_array($tocountry) && count($tocountry) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tocountry when calling gETDeliveryCheckoutsDeliveryCheckoutId'
            );
        }
        // verify the required parameter 'tozipcode' is set
        if ($tozipcode === null || (is_array($tozipcode) && count($tozipcode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tozipcode when calling gETDeliveryCheckoutsDeliveryCheckoutId'
            );
        }

        $resourcePath = '/delivery-checkouts/{deliveryCheckoutId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($currency !== null) {
            $queryParams['currency'] = ObjectSerializer::toQueryValue($currency);
        }
        // query params
        if ($tocountry !== null) {
            $queryParams['tocountry'] = ObjectSerializer::toQueryValue($tocountry);
        }
        // query params
        if ($tozipcode !== null) {
            $queryParams['tozipcode'] = ObjectSerializer::toQueryValue($tozipcode);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($delivery_checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deliveryCheckoutId' . '}',
                ObjectSerializer::toPathValue($delivery_checkout_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETMetaListsPartners
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $language The language code to use for any description texts. (optional)
     * @param  string $favorite The name of a print favorite to use. Any filters configured in the favorite will be applied to the result of this call. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MetaListPartnerList
     */
    public function gETMetaListsPartners($authorization = null, $language = null, $favorite = null)
    {
        list($response) = $this->gETMetaListsPartnersWithHttpInfo($authorization, $language, $favorite);
        return $response;
    }

    /**
     * Operation gETMetaListsPartnersWithHttpInfo
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $language The language code to use for any description texts. (optional)
     * @param  string $favorite The name of a print favorite to use. Any filters configured in the favorite will be applied to the result of this call. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MetaListPartnerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETMetaListsPartnersWithHttpInfo($authorization = null, $language = null, $favorite = null)
    {
        $returnType = '\Swagger\Client\Model\MetaListPartnerList';
        $request = $this->gETMetaListsPartnersRequest($authorization, $language, $favorite);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MetaListPartnerList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETMetaListsPartnersAsync
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $language The language code to use for any description texts. (optional)
     * @param  string $favorite The name of a print favorite to use. Any filters configured in the favorite will be applied to the result of this call. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETMetaListsPartnersAsync($authorization = null, $language = null, $favorite = null)
    {
        return $this->gETMetaListsPartnersAsyncWithHttpInfo($authorization, $language, $favorite)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETMetaListsPartnersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $language The language code to use for any description texts. (optional)
     * @param  string $favorite The name of a print favorite to use. Any filters configured in the favorite will be applied to the result of this call. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETMetaListsPartnersAsyncWithHttpInfo($authorization = null, $language = null, $favorite = null)
    {
        $returnType = '\Swagger\Client\Model\MetaListPartnerList';
        $request = $this->gETMetaListsPartnersRequest($authorization, $language, $favorite);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETMetaListsPartners'
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $language The language code to use for any description texts. (optional)
     * @param  string $favorite The name of a print favorite to use. Any filters configured in the favorite will be applied to the result of this call. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETMetaListsPartnersRequest($authorization = null, $language = null, $favorite = null)
    {

        $resourcePath = '/meta/lists/partners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($favorite !== null) {
            $queryParams['favorite'] = ObjectSerializer::toQueryValue($favorite);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETOnboardingAccounts
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $org_no The organisation number of the account to search for. (optional)
     * @param  string $user_id The user id of the account to search for. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AccountList
     */
    public function gETOnboardingAccounts($authorization = null, $org_no = null, $user_id = null)
    {
        list($response) = $this->gETOnboardingAccountsWithHttpInfo($authorization, $org_no, $user_id);
        return $response;
    }

    /**
     * Operation gETOnboardingAccountsWithHttpInfo
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $org_no The organisation number of the account to search for. (optional)
     * @param  string $user_id The user id of the account to search for. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AccountList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETOnboardingAccountsWithHttpInfo($authorization = null, $org_no = null, $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\AccountList';
        $request = $this->gETOnboardingAccountsRequest($authorization, $org_no, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AccountList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETOnboardingAccountsAsync
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $org_no The organisation number of the account to search for. (optional)
     * @param  string $user_id The user id of the account to search for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETOnboardingAccountsAsync($authorization = null, $org_no = null, $user_id = null)
    {
        return $this->gETOnboardingAccountsAsyncWithHttpInfo($authorization, $org_no, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETOnboardingAccountsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $org_no The organisation number of the account to search for. (optional)
     * @param  string $user_id The user id of the account to search for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETOnboardingAccountsAsyncWithHttpInfo($authorization = null, $org_no = null, $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\AccountList';
        $request = $this->gETOnboardingAccountsRequest($authorization, $org_no, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETOnboardingAccounts'
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $org_no The organisation number of the account to search for. (optional)
     * @param  string $user_id The user id of the account to search for. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETOnboardingAccountsRequest($authorization = null, $org_no = null, $user_id = null)
    {

        $resourcePath = '/onboarding/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($org_no !== null) {
            $queryParams['orgNo'] = ObjectSerializer::toQueryValue($org_no);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETOnboardingApplicationsLanguage
     *
     * @param  string $language language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\OnboardingApplications
     */
    public function gETOnboardingApplicationsLanguage($language, $authorization = null)
    {
        list($response) = $this->gETOnboardingApplicationsLanguageWithHttpInfo($language, $authorization);
        return $response;
    }

    /**
     * Operation gETOnboardingApplicationsLanguageWithHttpInfo
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\OnboardingApplications, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETOnboardingApplicationsLanguageWithHttpInfo($language, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\OnboardingApplications';
        $request = $this->gETOnboardingApplicationsLanguageRequest($language, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\OnboardingApplications',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETOnboardingApplicationsLanguageAsync
     *
     * 
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETOnboardingApplicationsLanguageAsync($language, $authorization = null)
    {
        return $this->gETOnboardingApplicationsLanguageAsyncWithHttpInfo($language, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETOnboardingApplicationsLanguageAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETOnboardingApplicationsLanguageAsyncWithHttpInfo($language, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\OnboardingApplications';
        $request = $this->gETOnboardingApplicationsLanguageRequest($language, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETOnboardingApplicationsLanguage'
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETOnboardingApplicationsLanguageRequest($language, $authorization = null)
    {
        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling gETOnboardingApplicationsLanguage'
            );
        }

        $resourcePath = '/onboarding/applications/{language}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($language !== null) {
            $resourcePath = str_replace(
                '{' . 'language' . '}',
                ObjectSerializer::toPathValue($language),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETOnboardingTermsLanguage
     *
     * @param  string $language language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\OnboardingTerms
     */
    public function gETOnboardingTermsLanguage($language, $authorization = null)
    {
        list($response) = $this->gETOnboardingTermsLanguageWithHttpInfo($language, $authorization);
        return $response;
    }

    /**
     * Operation gETOnboardingTermsLanguageWithHttpInfo
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\OnboardingTerms, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETOnboardingTermsLanguageWithHttpInfo($language, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\OnboardingTerms';
        $request = $this->gETOnboardingTermsLanguageRequest($language, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\OnboardingTerms',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETOnboardingTermsLanguageAsync
     *
     * 
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETOnboardingTermsLanguageAsync($language, $authorization = null)
    {
        return $this->gETOnboardingTermsLanguageAsyncWithHttpInfo($language, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETOnboardingTermsLanguageAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETOnboardingTermsLanguageAsyncWithHttpInfo($language, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\OnboardingTerms';
        $request = $this->gETOnboardingTermsLanguageRequest($language, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETOnboardingTermsLanguage'
     *
     * @param  string $language (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETOnboardingTermsLanguageRequest($language, $authorization = null)
    {
        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling gETOnboardingTermsLanguage'
            );
        }

        $resourcePath = '/onboarding/terms/{language}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($language !== null) {
            $resourcePath = str_replace(
                '{' . 'language' . '}',
                ObjectSerializer::toPathValue($language),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETPreparedShipmentsPrepareId
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shipment
     */
    public function gETPreparedShipmentsPrepareId($prepare_id, $authorization = null)
    {
        list($response) = $this->gETPreparedShipmentsPrepareIdWithHttpInfo($prepare_id, $authorization);
        return $response;
    }

    /**
     * Operation gETPreparedShipmentsPrepareIdWithHttpInfo
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shipment, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETPreparedShipmentsPrepareIdWithHttpInfo($prepare_id, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->gETPreparedShipmentsPrepareIdRequest($prepare_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shipment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETPreparedShipmentsPrepareIdAsync
     *
     * 
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETPreparedShipmentsPrepareIdAsync($prepare_id, $authorization = null)
    {
        return $this->gETPreparedShipmentsPrepareIdAsyncWithHttpInfo($prepare_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETPreparedShipmentsPrepareIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETPreparedShipmentsPrepareIdAsyncWithHttpInfo($prepare_id, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->gETPreparedShipmentsPrepareIdRequest($prepare_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETPreparedShipmentsPrepareId'
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETPreparedShipmentsPrepareIdRequest($prepare_id, $authorization = null)
    {
        // verify the required parameter 'prepare_id' is set
        if ($prepare_id === null || (is_array($prepare_id) && count($prepare_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepare_id when calling gETPreparedShipmentsPrepareId'
            );
        }

        $resourcePath = '/prepared-shipments/{prepareId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($prepare_id !== null) {
            $resourcePath = str_replace(
                '{' . 'prepareId' . '}',
                ObjectSerializer::toPathValue($prepare_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETShipments
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentFetchInfoList
     */
    public function gETShipments($authorization = null, $fetch_id = null)
    {
        list($response) = $this->gETShipmentsWithHttpInfo($authorization, $fetch_id);
        return $response;
    }

    /**
     * Operation gETShipmentsWithHttpInfo
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentFetchInfoList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETShipmentsWithHttpInfo($authorization = null, $fetch_id = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentFetchInfoList';
        $request = $this->gETShipmentsRequest($authorization, $fetch_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentFetchInfoList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETShipmentsAsync
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsAsync($authorization = null, $fetch_id = null)
    {
        return $this->gETShipmentsAsyncWithHttpInfo($authorization, $fetch_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsAsyncWithHttpInfo($authorization = null, $fetch_id = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentFetchInfoList';
        $request = $this->gETShipmentsRequest($authorization, $fetch_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETShipments'
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETShipmentsRequest($authorization = null, $fetch_id = null)
    {

        $resourcePath = '/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fetch_id !== null) {
            $queryParams['fetchId'] = ObjectSerializer::toQueryValue($fetch_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETShipmentsShipmentIdPdfs
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PdfList
     */
    public function gETShipmentsShipmentIdPdfs($shipment_id, $authorization = null, $inline_pdf = null)
    {
        list($response) = $this->gETShipmentsShipmentIdPdfsWithHttpInfo($shipment_id, $authorization, $inline_pdf);
        return $response;
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsWithHttpInfo
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PdfList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETShipmentsShipmentIdPdfsWithHttpInfo($shipment_id, $authorization = null, $inline_pdf = null)
    {
        $returnType = '\Swagger\Client\Model\PdfList';
        $request = $this->gETShipmentsShipmentIdPdfsRequest($shipment_id, $authorization, $inline_pdf);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PdfList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsAsync
     *
     * 
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPdfsAsync($shipment_id, $authorization = null, $inline_pdf = null)
    {
        return $this->gETShipmentsShipmentIdPdfsAsyncWithHttpInfo($shipment_id, $authorization, $inline_pdf)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPdfsAsyncWithHttpInfo($shipment_id, $authorization = null, $inline_pdf = null)
    {
        $returnType = '\Swagger\Client\Model\PdfList';
        $request = $this->gETShipmentsShipmentIdPdfsRequest($shipment_id, $authorization, $inline_pdf);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETShipmentsShipmentIdPdfs'
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include PDF as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETShipmentsShipmentIdPdfsRequest($shipment_id, $authorization = null, $inline_pdf = null)
    {
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling gETShipmentsShipmentIdPdfs'
            );
        }

        $resourcePath = '/shipments/{shipmentId}/pdfs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_pdf !== null) {
            $queryParams['inlinePdf'] = ObjectSerializer::toQueryValue($inline_pdf);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsPdfId
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function gETShipmentsShipmentIdPdfsPdfId($pdf_id, $shipment_id, $authorization = null)
    {
        $this->gETShipmentsShipmentIdPdfsPdfIdWithHttpInfo($pdf_id, $shipment_id, $authorization);
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsPdfIdWithHttpInfo
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETShipmentsShipmentIdPdfsPdfIdWithHttpInfo($pdf_id, $shipment_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETShipmentsShipmentIdPdfsPdfIdRequest($pdf_id, $shipment_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsPdfIdAsync
     *
     * 
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPdfsPdfIdAsync($pdf_id, $shipment_id, $authorization = null)
    {
        return $this->gETShipmentsShipmentIdPdfsPdfIdAsyncWithHttpInfo($pdf_id, $shipment_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETShipmentsShipmentIdPdfsPdfIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPdfsPdfIdAsyncWithHttpInfo($pdf_id, $shipment_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETShipmentsShipmentIdPdfsPdfIdRequest($pdf_id, $shipment_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETShipmentsShipmentIdPdfsPdfId'
     *
     * @param  string $pdf_id The ID of a PDF document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETShipmentsShipmentIdPdfsPdfIdRequest($pdf_id, $shipment_id, $authorization = null)
    {
        // verify the required parameter 'pdf_id' is set
        if ($pdf_id === null || (is_array($pdf_id) && count($pdf_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pdf_id when calling gETShipmentsShipmentIdPdfsPdfId'
            );
        }
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling gETShipmentsShipmentIdPdfsPdfId'
            );
        }

        $resourcePath = '/shipments/{shipmentId}/pdfs/{pdfId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($pdf_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pdfId' . '}',
                ObjectSerializer::toPathValue($pdf_id),
                $resourcePath
            );
        }
        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/pdf', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/pdf', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETShipmentsShipmentIdPrints
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PrintList
     */
    public function gETShipmentsShipmentIdPrints($shipment_id, $authorization = null, $return_file = null)
    {
        list($response) = $this->gETShipmentsShipmentIdPrintsWithHttpInfo($shipment_id, $authorization, $return_file);
        return $response;
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsWithHttpInfo
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PrintList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETShipmentsShipmentIdPrintsWithHttpInfo($shipment_id, $authorization = null, $return_file = null)
    {
        $returnType = '\Swagger\Client\Model\PrintList';
        $request = $this->gETShipmentsShipmentIdPrintsRequest($shipment_id, $authorization, $return_file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PrintList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsAsync
     *
     * 
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPrintsAsync($shipment_id, $authorization = null, $return_file = null)
    {
        return $this->gETShipmentsShipmentIdPrintsAsyncWithHttpInfo($shipment_id, $authorization, $return_file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPrintsAsyncWithHttpInfo($shipment_id, $authorization = null, $return_file = null)
    {
        $returnType = '\Swagger\Client\Model\PrintList';
        $request = $this->gETShipmentsShipmentIdPrintsRequest($shipment_id, $authorization, $return_file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETShipmentsShipmentIdPrints'
     *
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $return_file Include document as base64 encoded value in result. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETShipmentsShipmentIdPrintsRequest($shipment_id, $authorization = null, $return_file = null)
    {
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling gETShipmentsShipmentIdPrints'
            );
        }

        $resourcePath = '/shipments/{shipmentId}/prints';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($return_file !== null) {
            $queryParams['returnFile'] = ObjectSerializer::toQueryValue($return_file);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsPrintId
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function gETShipmentsShipmentIdPrintsPrintId($print_id, $shipment_id, $authorization = null)
    {
        $this->gETShipmentsShipmentIdPrintsPrintIdWithHttpInfo($print_id, $shipment_id, $authorization);
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsPrintIdWithHttpInfo
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETShipmentsShipmentIdPrintsPrintIdWithHttpInfo($print_id, $shipment_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETShipmentsShipmentIdPrintsPrintIdRequest($print_id, $shipment_id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsPrintIdAsync
     *
     * 
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPrintsPrintIdAsync($print_id, $shipment_id, $authorization = null)
    {
        return $this->gETShipmentsShipmentIdPrintsPrintIdAsyncWithHttpInfo($print_id, $shipment_id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETShipmentsShipmentIdPrintsPrintIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETShipmentsShipmentIdPrintsPrintIdAsyncWithHttpInfo($print_id, $shipment_id, $authorization = null)
    {
        $returnType = '';
        $request = $this->gETShipmentsShipmentIdPrintsPrintIdRequest($print_id, $shipment_id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETShipmentsShipmentIdPrintsPrintId'
     *
     * @param  string $print_id The ID of a PDF or ZPL document. (required)
     * @param  string $shipment_id The ID of a shipment (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETShipmentsShipmentIdPrintsPrintIdRequest($print_id, $shipment_id, $authorization = null)
    {
        // verify the required parameter 'print_id' is set
        if ($print_id === null || (is_array($print_id) && count($print_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $print_id when calling gETShipmentsShipmentIdPrintsPrintId'
            );
        }
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling gETShipmentsShipmentIdPrintsPrintId'
            );
        }

        $resourcePath = '/shipments/{shipmentId}/prints/{printId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($print_id !== null) {
            $resourcePath = str_replace(
                '{' . 'printId' . '}',
                ObjectSerializer::toPathValue($print_id),
                $resourcePath
            );
        }
        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gETStoredShipments
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StoredShipmentInfoList
     */
    public function gETStoredShipments($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        list($response) = $this->gETStoredShipmentsWithHttpInfo($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status);
        return $response;
    }

    /**
     * Operation gETStoredShipmentsWithHttpInfo
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StoredShipmentInfoList, HTTP status code, HTTP response headers (array of strings)
     */
    public function gETStoredShipmentsWithHttpInfo($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        $returnType = '\Swagger\Client\Model\StoredShipmentInfoList';
        $request = $this->gETStoredShipmentsRequest($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StoredShipmentInfoList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gETStoredShipmentsAsync
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETStoredShipmentsAsync($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        return $this->gETStoredShipmentsAsyncWithHttpInfo($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gETStoredShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gETStoredShipmentsAsyncWithHttpInfo($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {
        $returnType = '\Swagger\Client\Model\StoredShipmentInfoList';
        $request = $this->gETStoredShipmentsRequest($authorization, $search_field, $search_op, $search_value, $date_type, $date_from, $date_to, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gETStoredShipments'
     *
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $search_field The field to search in. (optional)
     * @param  string $search_op The operator used on the field. (optional)
     * @param  string $search_value The value to search for in the field (optional)
     * @param  string $date_type The type of date to filter on. (optional)
     * @param  string $date_from The lower limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $date_to The upper limit of a date interval to filter on. Must be in ISO-8601 date format. (optional)
     * @param  string $status The status value to filter on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function gETStoredShipmentsRequest($authorization = null, $search_field = null, $search_op = null, $search_value = null, $date_type = null, $date_from = null, $date_to = null, $status = null)
    {

        $resourcePath = '/stored-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_field !== null) {
            $queryParams['searchField'] = ObjectSerializer::toQueryValue($search_field);
        }
        // query params
        if ($search_op !== null) {
            $queryParams['searchOp'] = ObjectSerializer::toQueryValue($search_op);
        }
        // query params
        if ($search_value !== null) {
            $queryParams['searchValue'] = ObjectSerializer::toQueryValue($search_value);
        }
        // query params
        if ($date_type !== null) {
            $queryParams['dateType'] = ObjectSerializer::toQueryValue($date_type);
        }
        // query params
        if ($date_from !== null) {
            $queryParams['dateFrom'] = ObjectSerializer::toQueryValue($date_from);
        }
        // query params
        if ($date_to !== null) {
            $queryParams['dateTo'] = ObjectSerializer::toQueryValue($date_to);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTAgents
     *
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pOSTAgents($body = null, $authorization = null)
    {
        $this->pOSTAgentsWithHttpInfo($body, $authorization);
    }

    /**
     * Operation pOSTAgentsWithHttpInfo
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTAgentsWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '';
        $request = $this->pOSTAgentsRequest($body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTAgentsAsync
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTAgentsAsync($body = null, $authorization = null)
    {
        return $this->pOSTAgentsAsyncWithHttpInfo($body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTAgentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTAgentsAsyncWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '';
        $request = $this->pOSTAgentsRequest($body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTAgents'
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTAgentsRequest($body = null, $authorization = null)
    {

        $resourcePath = '/agents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTAgentsId
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pOSTAgentsId($id, $authorization = null)
    {
        $this->pOSTAgentsIdWithHttpInfo($id, $authorization);
    }

    /**
     * Operation pOSTAgentsIdWithHttpInfo
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTAgentsIdWithHttpInfo($id, $authorization = null)
    {
        $returnType = '';
        $request = $this->pOSTAgentsIdRequest($id, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTAgentsIdAsync
     *
     * 
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTAgentsIdAsync($id, $authorization = null)
    {
        return $this->pOSTAgentsIdAsyncWithHttpInfo($id, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTAgentsIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTAgentsIdAsyncWithHttpInfo($id, $authorization = null)
    {
        $returnType = '';
        $request = $this->pOSTAgentsIdRequest($id, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTAgentsId'
     *
     * @param  string $id The ID of an agent list. (required)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTAgentsIdRequest($id, $authorization = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pOSTAgentsId'
            );
        }

        $resourcePath = '/agents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTConsolidatedShipments
     *
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfoList
     */
    public function pOSTConsolidatedShipments($body = null, $authorization = null)
    {
        list($response) = $this->pOSTConsolidatedShipmentsWithHttpInfo($body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTConsolidatedShipmentsWithHttpInfo
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfoList, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTConsolidatedShipmentsWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfoList';
        $request = $this->pOSTConsolidatedShipmentsRequest($body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfoList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatusList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTConsolidatedShipmentsAsync
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTConsolidatedShipmentsAsync($body = null, $authorization = null)
    {
        return $this->pOSTConsolidatedShipmentsAsyncWithHttpInfo($body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTConsolidatedShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTConsolidatedShipmentsAsyncWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfoList';
        $request = $this->pOSTConsolidatedShipmentsRequest($body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTConsolidatedShipments'
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTConsolidatedShipmentsRequest($body = null, $authorization = null)
    {

        $resourcePath = '/consolidated-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipments
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfo
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipments($consolidated_id, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsWithHttpInfo($consolidated_id, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsWithHttpInfo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsWithHttpInfo($consolidated_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsRequest($consolidated_id, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsAsync
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsAsync($consolidated_id, $body = null, $authorization = null)
    {
        return $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsAsyncWithHttpInfo($consolidated_id, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsAsyncWithHttpInfo($consolidated_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsRequest($consolidated_id, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTConsolidatedShipmentsConsolidatedIdShipments'
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTConsolidatedShipmentsConsolidatedIdShipmentsRequest($consolidated_id, $body = null, $authorization = null)
    {
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling pOSTConsolidatedShipmentsConsolidatedIdShipments'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifest
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfo
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifest($consolidated_id, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestWithHttpInfo($consolidated_id, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestWithHttpInfo
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestWithHttpInfo($consolidated_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestRequest($consolidated_id, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestAsync
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestAsync($consolidated_id, $body = null, $authorization = null)
    {
        return $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestAsyncWithHttpInfo($consolidated_id, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestAsyncWithHttpInfo($consolidated_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestRequest($consolidated_id, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifest'
     *
     * @param  string $consolidated_id The ID of a consolidated shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifestRequest($consolidated_id, $body = null, $authorization = null)
    {
        // verify the required parameter 'consolidated_id' is set
        if ($consolidated_id === null || (is_array($consolidated_id) && count($consolidated_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidated_id when calling pOSTConsolidatedShipmentsConsolidatedIdShipmentsManifest'
            );
        }

        $resourcePath = '/consolidated-shipments/{consolidatedId}/shipments/manifest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($consolidated_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consolidatedId' . '}',
                ObjectSerializer::toPathValue($consolidated_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutId
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shipment
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutId($delivery_checkout_id, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdWithHttpInfo($delivery_checkout_id, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdWithHttpInfo
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shipment, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdWithHttpInfo($delivery_checkout_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdRequest($delivery_checkout_id, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shipment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdAsync
     *
     * 
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdAsync($delivery_checkout_id, $body = null, $authorization = null)
    {
        return $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdAsyncWithHttpInfo($delivery_checkout_id, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdAsyncWithHttpInfo($delivery_checkout_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdRequest($delivery_checkout_id, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTDeliveryCheckoutsDeliveryCheckoutId'
     *
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTDeliveryCheckoutsDeliveryCheckoutIdRequest($delivery_checkout_id, $body = null, $authorization = null)
    {
        // verify the required parameter 'delivery_checkout_id' is set
        if ($delivery_checkout_id === null || (is_array($delivery_checkout_id) && count($delivery_checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delivery_checkout_id when calling pOSTDeliveryCheckoutsDeliveryCheckoutId'
            );
        }

        $resourcePath = '/delivery-checkouts/{deliveryCheckoutId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($delivery_checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deliveryCheckoutId' . '}',
                ObjectSerializer::toPathValue($delivery_checkout_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrency
     *
     * @param  string $currency currency (required)
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shipment
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrency($currency, $delivery_checkout_id, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyWithHttpInfo($currency, $delivery_checkout_id, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyWithHttpInfo
     *
     * @param  string $currency (required)
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shipment, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyWithHttpInfo($currency, $delivery_checkout_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyRequest($currency, $delivery_checkout_id, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shipment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyAsync
     *
     * 
     *
     * @param  string $currency (required)
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyAsync($currency, $delivery_checkout_id, $body = null, $authorization = null)
    {
        return $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyAsyncWithHttpInfo($currency, $delivery_checkout_id, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $currency (required)
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyAsyncWithHttpInfo($currency, $delivery_checkout_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyRequest($currency, $delivery_checkout_id, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrency'
     *
     * @param  string $currency (required)
     * @param  string $delivery_checkout_id The delivery checkout ID. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrencyRequest($currency, $delivery_checkout_id, $body = null, $authorization = null)
    {
        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrency'
            );
        }
        // verify the required parameter 'delivery_checkout_id' is set
        if ($delivery_checkout_id === null || (is_array($delivery_checkout_id) && count($delivery_checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delivery_checkout_id when calling pOSTDeliveryCheckoutsDeliveryCheckoutIdSummaryCurrency'
            );
        }

        $resourcePath = '/delivery-checkouts/{deliveryCheckoutId}/summary/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }
        // path params
        if ($delivery_checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deliveryCheckoutId' . '}',
                ObjectSerializer::toPathValue($delivery_checkout_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTOnboardingApplicationsApplicationCode
     *
     * @param  string $application_code application_code (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\OnboardingApplicationResult
     */
    public function pOSTOnboardingApplicationsApplicationCode($application_code, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTOnboardingApplicationsApplicationCodeWithHttpInfo($application_code, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTOnboardingApplicationsApplicationCodeWithHttpInfo
     *
     * @param  string $application_code (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\OnboardingApplicationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTOnboardingApplicationsApplicationCodeWithHttpInfo($application_code, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\OnboardingApplicationResult';
        $request = $this->pOSTOnboardingApplicationsApplicationCodeRequest($application_code, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\OnboardingApplicationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTOnboardingApplicationsApplicationCodeAsync
     *
     * 
     *
     * @param  string $application_code (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTOnboardingApplicationsApplicationCodeAsync($application_code, $body = null, $authorization = null)
    {
        return $this->pOSTOnboardingApplicationsApplicationCodeAsyncWithHttpInfo($application_code, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTOnboardingApplicationsApplicationCodeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $application_code (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTOnboardingApplicationsApplicationCodeAsyncWithHttpInfo($application_code, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\OnboardingApplicationResult';
        $request = $this->pOSTOnboardingApplicationsApplicationCodeRequest($application_code, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTOnboardingApplicationsApplicationCode'
     *
     * @param  string $application_code (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTOnboardingApplicationsApplicationCodeRequest($application_code, $body = null, $authorization = null)
    {
        // verify the required parameter 'application_code' is set
        if ($application_code === null || (is_array($application_code) && count($application_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_code when calling pOSTOnboardingApplicationsApplicationCode'
            );
        }

        $resourcePath = '/onboarding/applications/{applicationCode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($application_code !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationCode' . '}',
                ObjectSerializer::toPathValue($application_code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareId
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Shipment
     */
    public function pOSTPreparedShipmentsPrepareId($prepare_id, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTPreparedShipmentsPrepareIdWithHttpInfo($prepare_id, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdWithHttpInfo
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Shipment, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTPreparedShipmentsPrepareIdWithHttpInfo($prepare_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->pOSTPreparedShipmentsPrepareIdRequest($prepare_id, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Shipment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdAsync
     *
     * 
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPreparedShipmentsPrepareIdAsync($prepare_id, $body = null, $authorization = null)
    {
        return $this->pOSTPreparedShipmentsPrepareIdAsyncWithHttpInfo($prepare_id, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPreparedShipmentsPrepareIdAsyncWithHttpInfo($prepare_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Shipment';
        $request = $this->pOSTPreparedShipmentsPrepareIdRequest($prepare_id, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTPreparedShipmentsPrepareId'
     *
     * @param  string $prepare_id The prepare ID of a prepared shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTPreparedShipmentsPrepareIdRequest($prepare_id, $body = null, $authorization = null)
    {
        // verify the required parameter 'prepare_id' is set
        if ($prepare_id === null || (is_array($prepare_id) && count($prepare_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepare_id when calling pOSTPreparedShipmentsPrepareId'
            );
        }

        $resourcePath = '/prepared-shipments/{prepareId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($prepare_id !== null) {
            $resourcePath = str_replace(
                '{' . 'prepareId' . '}',
                ObjectSerializer::toPathValue($prepare_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdShipments
     *
     * @param  string $prepare_id prepare_id (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include document as base64 encoded value in result. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfo
     */
    public function pOSTPreparedShipmentsPrepareIdShipments($prepare_id, $body = null, $authorization = null, $inline_pdf = null, $keep_prepared_shipment = null)
    {
        list($response) = $this->pOSTPreparedShipmentsPrepareIdShipmentsWithHttpInfo($prepare_id, $body, $authorization, $inline_pdf, $keep_prepared_shipment);
        return $response;
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdShipmentsWithHttpInfo
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include document as base64 encoded value in result. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTPreparedShipmentsPrepareIdShipmentsWithHttpInfo($prepare_id, $body = null, $authorization = null, $inline_pdf = null, $keep_prepared_shipment = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTPreparedShipmentsPrepareIdShipmentsRequest($prepare_id, $body, $authorization, $inline_pdf, $keep_prepared_shipment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdShipmentsAsync
     *
     * 
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include document as base64 encoded value in result. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPreparedShipmentsPrepareIdShipmentsAsync($prepare_id, $body = null, $authorization = null, $inline_pdf = null, $keep_prepared_shipment = null)
    {
        return $this->pOSTPreparedShipmentsPrepareIdShipmentsAsyncWithHttpInfo($prepare_id, $body, $authorization, $inline_pdf, $keep_prepared_shipment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include document as base64 encoded value in result. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPreparedShipmentsPrepareIdShipmentsAsyncWithHttpInfo($prepare_id, $body = null, $authorization = null, $inline_pdf = null, $keep_prepared_shipment = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTPreparedShipmentsPrepareIdShipmentsRequest($prepare_id, $body, $authorization, $inline_pdf, $keep_prepared_shipment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTPreparedShipmentsPrepareIdShipments'
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $inline_pdf Include document as base64 encoded value in result. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTPreparedShipmentsPrepareIdShipmentsRequest($prepare_id, $body = null, $authorization = null, $inline_pdf = null, $keep_prepared_shipment = null)
    {
        // verify the required parameter 'prepare_id' is set
        if ($prepare_id === null || (is_array($prepare_id) && count($prepare_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepare_id when calling pOSTPreparedShipmentsPrepareIdShipments'
            );
        }

        $resourcePath = '/prepared-shipments/{prepareId}/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_pdf !== null) {
            $queryParams['inlinePdf'] = ObjectSerializer::toQueryValue($inline_pdf);
        }
        // query params
        if ($keep_prepared_shipment !== null) {
            $queryParams['keepPreparedShipment'] = ObjectSerializer::toQueryValue($keep_prepared_shipment);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($prepare_id !== null) {
            $resourcePath = str_replace(
                '{' . 'prepareId' . '}',
                ObjectSerializer::toPathValue($prepare_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdStoredShipments
     *
     * @param  string $prepare_id prepare_id (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StoredShipmentInfo
     */
    public function pOSTPreparedShipmentsPrepareIdStoredShipments($prepare_id, $body = null, $authorization = null, $keep_prepared_shipment = null)
    {
        list($response) = $this->pOSTPreparedShipmentsPrepareIdStoredShipmentsWithHttpInfo($prepare_id, $body, $authorization, $keep_prepared_shipment);
        return $response;
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdStoredShipmentsWithHttpInfo
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StoredShipmentInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTPreparedShipmentsPrepareIdStoredShipmentsWithHttpInfo($prepare_id, $body = null, $authorization = null, $keep_prepared_shipment = null)
    {
        $returnType = '\Swagger\Client\Model\StoredShipmentInfo';
        $request = $this->pOSTPreparedShipmentsPrepareIdStoredShipmentsRequest($prepare_id, $body, $authorization, $keep_prepared_shipment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StoredShipmentInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdStoredShipmentsAsync
     *
     * 
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPreparedShipmentsPrepareIdStoredShipmentsAsync($prepare_id, $body = null, $authorization = null, $keep_prepared_shipment = null)
    {
        return $this->pOSTPreparedShipmentsPrepareIdStoredShipmentsAsyncWithHttpInfo($prepare_id, $body, $authorization, $keep_prepared_shipment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTPreparedShipmentsPrepareIdStoredShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPreparedShipmentsPrepareIdStoredShipmentsAsyncWithHttpInfo($prepare_id, $body = null, $authorization = null, $keep_prepared_shipment = null)
    {
        $returnType = '\Swagger\Client\Model\StoredShipmentInfo';
        $request = $this->pOSTPreparedShipmentsPrepareIdStoredShipmentsRequest($prepare_id, $body, $authorization, $keep_prepared_shipment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTPreparedShipmentsPrepareIdStoredShipments'
     *
     * @param  string $prepare_id (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  bool $keep_prepared_shipment Should be set to true if the same prepareid should be used again. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTPreparedShipmentsPrepareIdStoredShipmentsRequest($prepare_id, $body = null, $authorization = null, $keep_prepared_shipment = null)
    {
        // verify the required parameter 'prepare_id' is set
        if ($prepare_id === null || (is_array($prepare_id) && count($prepare_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prepare_id when calling pOSTPreparedShipmentsPrepareIdStoredShipments'
            );
        }

        $resourcePath = '/prepared-shipments/{prepareId}/stored-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($keep_prepared_shipment !== null) {
            $queryParams['keepPreparedShipment'] = ObjectSerializer::toQueryValue($keep_prepared_shipment);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($prepare_id !== null) {
            $resourcePath = str_replace(
                '{' . 'prepareId' . '}',
                ObjectSerializer::toPathValue($prepare_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTPrices
     *
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Price
     */
    public function pOSTPrices($body = null, $authorization = null)
    {
        list($response) = $this->pOSTPricesWithHttpInfo($body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTPricesWithHttpInfo
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Price, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTPricesWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Price';
        $request = $this->pOSTPricesRequest($body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Price',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTPricesAsync
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPricesAsync($body = null, $authorization = null)
    {
        return $this->pOSTPricesAsyncWithHttpInfo($body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTPricesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPricesAsyncWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\Price';
        $request = $this->pOSTPricesRequest($body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTPrices'
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTPricesRequest($body = null, $authorization = null)
    {

        $resourcePath = '/prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTPricesHistory
     *
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PriceHistory
     */
    public function pOSTPricesHistory($body = null, $authorization = null, $fetch_id = null)
    {
        list($response) = $this->pOSTPricesHistoryWithHttpInfo($body, $authorization, $fetch_id);
        return $response;
    }

    /**
     * Operation pOSTPricesHistoryWithHttpInfo
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PriceHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTPricesHistoryWithHttpInfo($body = null, $authorization = null, $fetch_id = null)
    {
        $returnType = '\Swagger\Client\Model\PriceHistory';
        $request = $this->pOSTPricesHistoryRequest($body, $authorization, $fetch_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PriceHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTPricesHistoryAsync
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPricesHistoryAsync($body = null, $authorization = null, $fetch_id = null)
    {
        return $this->pOSTPricesHistoryAsyncWithHttpInfo($body, $authorization, $fetch_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTPricesHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTPricesHistoryAsyncWithHttpInfo($body = null, $authorization = null, $fetch_id = null)
    {
        $returnType = '\Swagger\Client\Model\PriceHistory';
        $request = $this->pOSTPricesHistoryRequest($body, $authorization, $fetch_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTPricesHistory'
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     * @param  string $fetch_id The ID of the next batch of shipments to fetch. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTPricesHistoryRequest($body = null, $authorization = null, $fetch_id = null)
    {

        $resourcePath = '/prices/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fetch_id !== null) {
            $queryParams['fetchId'] = ObjectSerializer::toQueryValue($fetch_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTShipments
     *
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfoList
     */
    public function pOSTShipments($body = null, $authorization = null)
    {
        list($response) = $this->pOSTShipmentsWithHttpInfo($body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTShipmentsWithHttpInfo
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfoList, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTShipmentsWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfoList';
        $request = $this->pOSTShipmentsRequest($body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfoList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StatusList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTShipmentsAsync
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTShipmentsAsync($body = null, $authorization = null)
    {
        return $this->pOSTShipmentsAsyncWithHttpInfo($body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTShipmentsAsyncWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfoList';
        $request = $this->pOSTShipmentsRequest($body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTShipments'
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTShipmentsRequest($body = null, $authorization = null)
    {

        $resourcePath = '/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTStoredShipments
     *
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StoredShipmentInfo
     */
    public function pOSTStoredShipments($body = null, $authorization = null)
    {
        list($response) = $this->pOSTStoredShipmentsWithHttpInfo($body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTStoredShipmentsWithHttpInfo
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StoredShipmentInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTStoredShipmentsWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\StoredShipmentInfo';
        $request = $this->pOSTStoredShipmentsRequest($body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StoredShipmentInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTStoredShipmentsAsync
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTStoredShipmentsAsync($body = null, $authorization = null)
    {
        return $this->pOSTStoredShipmentsAsyncWithHttpInfo($body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTStoredShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTStoredShipmentsAsyncWithHttpInfo($body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\StoredShipmentInfo';
        $request = $this->pOSTStoredShipmentsRequest($body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTStoredShipments'
     *
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTStoredShipmentsRequest($body = null, $authorization = null)
    {

        $resourcePath = '/stored-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pOSTStoredShipmentsStoredIdShipments
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $body body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShipmentInfo
     */
    public function pOSTStoredShipmentsStoredIdShipments($stored_id, $body = null, $authorization = null)
    {
        list($response) = $this->pOSTStoredShipmentsStoredIdShipmentsWithHttpInfo($stored_id, $body, $authorization);
        return $response;
    }

    /**
     * Operation pOSTStoredShipmentsStoredIdShipmentsWithHttpInfo
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShipmentInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function pOSTStoredShipmentsStoredIdShipmentsWithHttpInfo($stored_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTStoredShipmentsStoredIdShipmentsRequest($stored_id, $body, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShipmentInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pOSTStoredShipmentsStoredIdShipmentsAsync
     *
     * 
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTStoredShipmentsStoredIdShipmentsAsync($stored_id, $body = null, $authorization = null)
    {
        return $this->pOSTStoredShipmentsStoredIdShipmentsAsyncWithHttpInfo($stored_id, $body, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pOSTStoredShipmentsStoredIdShipmentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pOSTStoredShipmentsStoredIdShipmentsAsyncWithHttpInfo($stored_id, $body = null, $authorization = null)
    {
        $returnType = '\Swagger\Client\Model\ShipmentInfo';
        $request = $this->pOSTStoredShipmentsStoredIdShipmentsRequest($stored_id, $body, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pOSTStoredShipmentsStoredIdShipments'
     *
     * @param  string $stored_id The ID of a stored shipment. (required)
     * @param  string $body (optional)
     * @param  string $authorization Custom Bearer Token based on API key. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pOSTStoredShipmentsStoredIdShipmentsRequest($stored_id, $body = null, $authorization = null)
    {
        // verify the required parameter 'stored_id' is set
        if ($stored_id === null || (is_array($stored_id) && count($stored_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stored_id when calling pOSTStoredShipmentsStoredIdShipments'
            );
        }

        $resourcePath = '/stored-shipments/{storedId}/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($stored_id !== null) {
            $resourcePath = str_replace(
                '{' . 'storedId' . '}',
                ObjectSerializer::toPathValue($stored_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
